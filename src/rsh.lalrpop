grammar<'input>(input: &'input str);
use crate::{
	lexer::{self, LexerError},
	Command,
	CommandChain,
	Pipeline,
	ChainPart,
	StringValue,
	VariableDefinition,
	CommandContext,
	StringPart,
	RedirectionType,
	Type,
	Value,
};

extern {
	type Location = usize;
	type Error = LexerError;

	enum lexer::Token<'input> {
		"let" => lexer::Token::Let,
		"in" => lexer::Token::In,
		"int" => lexer::Token::Int,
		"str" => lexer::Token::Str,
		"any" => lexer::Token::Any,
		">" => lexer::Token::OutRedir,
		">>" => lexer::Token::AppendRedir,
		"<" => lexer::Token::InRedir,
		"(" => lexer::Token::LParen,
		")" => lexer::Token::RParen,
		"||" => lexer::Token::Or,
		"&&" => lexer::Token::And,
		"=" => lexer::Token::Equal,
		"$(" => lexer::Token::SubShell,
		"\n" => lexer::Token::Newline,
		"," => lexer::Token::Comma,
		";" => lexer::Token::Semicolon,
		":" => lexer::Token::Colon,
		"|" => lexer::Token::Pipe,
		id => lexer::Token::Identifier(<&'input str>),
		word => lexer::Token::Word(<&'input str>),
		str => lexer::Token::StrLitteral(<&'input str>),
		istr => lexer::Token::InterpolatedString(<&'input str>),
		int => lexer::Token::IntNum(<i64>),
	}
}

pub Command: Command<'input> = {
	<name:StringValue> <args:(<Value>)*> <redirections:(<Redirection>)*> => Command{<>},
};

Redirection: (RedirectionType, Value<'input>) = {
	">" <v:Value> => (RedirectionType::Out, v),
	"<" <v:Value> => (RedirectionType::In, v),
	">>" <v:Value> => (RedirectionType::Append, v),
};

Pipeline: Pipeline<'input> = {
	<mut commands:(<Command> "|")*> <trailing:Command> => {
		commands.push(trailing);
		Pipeline{ commands }
	}
};

ChainPart: ChainPart<'input> = {
	<p:Pipeline> => ChainPart::Pipeline(p),
	"(" <c:CommandChain> ")" => ChainPart::Chain(Box::new(c)),
};

pub CommandChain: CommandChain<'input> = {
	<c1:ChainPart> "||" <c2:CommandChain> => CommandChain::Or(c1, Box::new(c2)),
	<c1:ChainPart> "&&" <c2:CommandChain> => CommandChain::And(c1, Box::new(c2)),
	<c:Pipeline> => CommandChain::Pipeline(c),
};

Type: Type = {
	"int" => Type::Int,
	"any" => Type::Dynamic,
	"str" => Type::String,
}

VariableDefinition: VariableDefinition<'input> = {
	<name:Identifier> <ty:(":" <Type>)?> "=" <value:Value> => VariableDefinition{name, value, ty: ty.unwrap_or(Type::Dynamic)}
};

pub CommandList: Vec<CommandChain<'input>> = {
	<mut chains:(<CommandChain> ";")*> <trailing:CommandChain> => {
		chains.push(trailing);
		chains
	}
};

Identifier: &'input str = {
	id => <>,
};

pub CommandContext: CommandContext<'input> = {
	"let" <mut variables:(<VariableDefinition> ",")*> <trailing:VariableDefinition?> "in" <commands:CommandList> => {
		CommandContext{
			commands,
			variables: match trailing {
				None => variables,
				Some(v) => {variables.push(v); variables}
			}
		}
	},
	<commands:CommandList> => CommandContext{commands, variables: Vec::new()},
};

pub Script: Vec<CommandContext<'input>> = {
	<mut cmds:(<CommandContext> "\n")*> <trl:CommandContext> <_last_newline:"\n"?> => {
		cmds.push(trl);
		cmds
	}
}

Word: &'input str = {
	word => <>,
	id => <>,
}

StringValue: StringValue<'input> = {
	"$(" <cmd:CommandContext> ")" => StringValue::SubShell(Box::new(cmd)),
	str => StringValue::Litteral(<>),
	Word => StringValue::Interpolated(StringPart::interpolate(<>)),
	istr => StringValue::Interpolated(StringPart::interpolate(<>)),
};

IntValue: i64 = {
	int => <>,
};

Value: Value<'input> = {
	StringValue => Value::String(<>),
	IntValue => Value::Int(<>),
};
