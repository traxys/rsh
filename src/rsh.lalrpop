grammar;
use crate::{
	Command,
	CommandChain,
	Pipeline,
	ChainPart,
	StringValue,
	VariableDefinition,
	CommandContext,
	StringPart,
	RedirectionType,
	Type,
	Value,
};
use lalrpop_util::ParseError;
use regex::Regex;

pub Command: Command<'input> = {
	<name:StringValue> <args:(<Value>)*> <redirections:(<Redirection>)*> => Command{<>},
};

Redirection: (RedirectionType, Value<'input>) = {
	">" <v:Value> => (RedirectionType::Out, v),
	"<" <v:Value> => (RedirectionType::In, v),
	">>" <v:Value> => (RedirectionType::Append, v),
};

Pipeline: Pipeline<'input> = {
	<mut commands:(<Command> "|")*> <trailing:Command> => {
		commands.push(trailing);
		Pipeline{ commands }
	}
};

ChainPart: ChainPart<'input> = {
	<p:Pipeline> => ChainPart::Pipeline(p),
	"(" <c:CommandChain> ")" => ChainPart::Chain(Box::new(c)),
};

pub CommandChain: CommandChain<'input> = {
	<c1:ChainPart> "||" <c2:CommandChain> => CommandChain::Or(c1, Box::new(c2)),
	<c1:ChainPart> "&&" <c2:CommandChain> => CommandChain::And(c1, Box::new(c2)),
	<c:Pipeline> => CommandChain::Pipeline(c),
};

Type: Type = {
	"int" => Type::Int,
	"any" => Type::Dynamic,
	"str" => Type::String,
}

VariableDefinition: VariableDefinition<'input> = {
	<name:Identifier> <ty:(":" <Type>)?> "=" <value:Value> => VariableDefinition{name, value, ty: ty.unwrap_or(Type::Dynamic)}
};

pub CommandList: Vec<CommandChain<'input>> = {
	<mut chains:(<CommandChain> ";")*> <trailing:CommandChain> => {
		chains.push(trailing);
		chains
	}
};

Identifier: &'input str = {
	Word =>? if Regex::new(r"[:+\-/.,]").unwrap().is_match(<>) { Err(ParseError::User{error: "invalid identifer"}) } else { Ok(<>) },
};

pub CommandContext: CommandContext<'input> = {
	"let" <mut variables:(<VariableDefinition> ",")*> <trailing:VariableDefinition?> "in" <commands:CommandList> => {
		CommandContext{
			commands,
			variables: match trailing {
				None => variables,
				Some(v) => {variables.push(v); variables}
			}
		}
	},
	<commands:CommandList> => CommandContext{commands, variables: Vec::new()},
};

Word: &'input str = {
	r"[\w\d:+\-_/.,$]+" => <>,
}

StringValue: StringValue<'input> = {
	"$(" <cmd:CommandContext> ")" => StringValue::SubShell(Box::new(cmd)),
	<s:r#"'(\\[^\n]|[^'\n])*'"#> => StringValue::Litteral(&s[1..(s.len()-1)]),
	Word => StringValue::Interpolated(StringPart::interpolate(<>)),
	<s:r#""(\\[^\n]|[^"\n])*""#> => StringValue::Interpolated(StringPart::interpolate(&s[1..(s.len()-1)])),
};

IntValue: i64 = {
	r"[0-9_]+" => <>.bytes().filter(|&b| b != b'_').fold(0, |current, digit| 10*current + (digit - b'0') as i64),
};

Value: Value<'input> = {
	StringValue => Value::String(<>),
	IntValue => Value::Int(<>),
};

match {
	"let",
	"in",
	":",
	"str",
	"int",
	"any",
} else {
	r"[0-9_]+",
} else {
	r"[\w\d:+\-_/.,$]+",
} else {
	r"[a-zA-Z_0-9]+",
	_,
}
