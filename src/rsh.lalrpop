grammar<'input>(ctx: &mut ShellContext, input: &'input str);
use crate::{
	lexer::{self, LexerError},
	Command,
	CommandChain,
	Pipeline,
	ChainPart,
	VariableDefinition,
	CommandContext,
	StringPart,
	RedirectionType,
	Type,
	Value,
	Expression,
	ShellContext,
};
use lasso::Spur;

extern {
	type Location = usize;
	type Error = LexerError;

	enum lexer::Token<'input> {
		"let" => lexer::Token::Let,
		"in" => lexer::Token::In,
		"int" => lexer::Token::Int,
		"str" => lexer::Token::Str,
		"any" => lexer::Token::Any,
		">" => lexer::Token::OutRedir,
		">>" => lexer::Token::AppendRedir,
		"<" => lexer::Token::InRedir,
		"(" => lexer::Token::LParen,
		")" => lexer::Token::RParen,
		"||" => lexer::Token::Or,
		"&&" => lexer::Token::And,
		"=" => lexer::Token::Equal,
		"$(" => lexer::Token::SubShell,
		"\n" => lexer::Token::Newline,
		"," => lexer::Token::Comma,
		";" => lexer::Token::Semicolon,
		":" => lexer::Token::Colon,
		"|" => lexer::Token::Pipe,
		id => lexer::Token::Identifier(<&'input str>),
		word => lexer::Token::Word(<&'input str>),
		str => lexer::Token::StrLitteral(<&'input str>),
		istr => lexer::Token::InterpolatedString(<&'input str>),
		int => lexer::Token::IntNum(<i64>),
	}
}

Value: Value<'input> = {
	str => Value::String(<>),
	int => Value::Int(<>),
};

Word: &'input str = {
	word => <>,
	id => <>,
};

Expression: Expression<'input> = {
	Value => Expression::Value(<>),
	<fun:Expression> "(" <mut exps:(<Expression> ",")*> <tl:Expression?> ")" => Expression::Call {
		function: Box::new(fun),
		args: match tl {
			Some(t) => {
				exps.push(t);
				exps
			},
			None => exps,
		}
	},
	Word => Expression::Interpolated(StringPart::interpolate(<>, ctx)),
	istr => Expression::Interpolated(StringPart::interpolate(<>, ctx)),
	"$(" <cmd:CommandContext> ")" => Expression::SubShell(Box::new(cmd)),
};

Redirection: (RedirectionType, Expression<'input>) = {
	">" <v:Expression> => (RedirectionType::Out, v),
	"<" <v:Expression> => (RedirectionType::In, v),
	">>" <v:Expression> => (RedirectionType::Append, v),
};

pub Command: Command<'input> = {
	<name:Expression> <args:(<Expression>)*> <redirections:(<Redirection>)*> => Command{<>},
};

Pipeline: Pipeline<'input> = {
	<mut commands:(<Command> "|")*> <trailing:Command> => {
		commands.push(trailing);
		Pipeline{ commands }
	}
};

ChainPart: ChainPart<'input> = {
	<p:Pipeline> => ChainPart::Pipeline(p),
	"(" <c:CommandChain> ")" => ChainPart::Chain(Box::new(c)),
};

pub CommandChain: CommandChain<'input> = {
	<c1:ChainPart> "||" <c2:CommandChain> => CommandChain::Or(c1, Box::new(c2)),
	<c1:ChainPart> "&&" <c2:CommandChain> => CommandChain::And(c1, Box::new(c2)),
	<c:Pipeline> => CommandChain::Pipeline(c),
};

pub CommandList: Vec<CommandChain<'input>> = {
	<mut chains:(<CommandChain> ";")*> <trailing:CommandChain> => {
		chains.push(trailing);
		chains
	}
};

Type: Type = {
	"int" => Type::Int,
	"any" => Type::Dynamic,
	"str" => Type::String,
};

Identifier: Spur = {
	id => ctx.rodeo.get_or_intern(<>),
};

VariableDefinition: VariableDefinition<'input> = {
	<name:Identifier> <ty:(":" <Type>)?> "=" <expr:Expression> => VariableDefinition{name, expr, ty: ty.unwrap_or(Type::Dynamic)}
};

pub CommandContext: CommandContext<'input> = {
	"let" <mut variables:(<VariableDefinition> ",")*> <trailing:VariableDefinition?> "in" <commands:CommandList> => {
		CommandContext{
			commands,
			variables: match trailing {
				None => variables,
				Some(v) => {variables.push(v); variables}
			}
		}
	},
	<commands:CommandList> => CommandContext{commands, variables: Vec::new()},
};


pub Script: Vec<CommandContext<'input>> = {
	<mut cmds:(<CommandContext> "\n")*> <trl:CommandContext> <_last_newline:"\n"?> => {
		cmds.push(trl);
		cmds
	}
};
